@startuml model_entities

package model.entities {

  ' I tipi delle carte in queste prime classi sono stati cambiati
  ' in accordo con le modifiche effettuate
  class Game {
    - players: List<Player>
    - numPlayers: int
    - resourceDeck: Stack<PhysicalCard>
    - goldDeck: Stack<PhysicalCard>
    - revealedResourceCards: PhysicalCard[2]
    - revealedGoldCards: PhysicalCard[2]
    - commonObjectives: ObjectiveCard[2]

    + start()
    + end()
    + join(Player)
    + setPlayerArea(Player)
    + getPlayerArea(Player)
    + setCommonGoals()
    + getCommonGoal1()
    + getCommonGoal2()
    + setPlayer(Player)
    + setDecks()
    + drawCard(DrawingPosition): RGCard
    - drawResourceDeck(): ResourceCard
    - drawGoldDeck(): GoldCard
  }

  enum DrawingPosition {
    RESOURCEDECK, RESOURCE1, RESOURCE2, GOLDDECK, GOLD1, GOLD2
  }

  ' Sincero non ho idea di come dovrebbe essere strutturata
  class Chat {
    ' ???
  }

  class Player {
    - nickname: String
    - status: PlayerStatus
    - playerData: PlayerArea

    + setNickname()
    + getNickname(): String
    + setStatus()
    + getStatus(): PlayerStatus
  }

  enum PlayerStatus {
    CONNECTED, DISCONNECTED, QUITTED
  }

  class PlayerArea {
    - cornersArea: Corner[82][82]
    - colorsArea: PlayableCard[82][82]
    - score: int
    - numResources: Map<Resources,int>
    - secretObjective: ObjectiveCard
    - hand: PhysicalCard[3]

    + getCornerArea()
    + getColorsArea()
    + getScore()
    + getNumResorces()
    + getSecretObjective()
    + getHand()
    - evaluateObjective(Objective): int
    + placeCard(PlayableCard,int,int): void
    - checkPlaceability(PlayableCard,int,int): boolean
    + drawCard(DrawingPosition): PhysicalCard
  }

  ' Aggiunta la risorsa nulla
  enum Resource {
    BLANK, PLANT, ANIMAL, FUNGI, INSECT, QUILL, SCROLL, INK
  }

  class Corner {
    - resource: Resource
    - visibility: boolean

    + getResource()
    + getVisibility()
  }

  class ObjectiveCard {
    ' Il punteggio dato dalla carta sarà calcolato come
    ' pointsPerCompletion * objective.checkCondition(player)
    + pointsPerCompletion: int
    + objective: Objective

    + getObjective()
  }

  '
  interface Objective {
    ' Indica il (massimo) numero di volte che un giocatore
    ' soddisfa l'obiettivo
    + checkCondition(Player): int
  }

  class IdenticalResourcesObjective implements Objective {
    - targetResource: Resource
    - count: int

    + checkCondition(Player): int
  }

  class DifferentResourcesObjective implements Objective {
    - targetSet: Set<Resource>

    + checkCondition(Player): int
  }

  class MonolithObjective implements Objective {
    - targetColor: Color
    - orientation: MonolithOrientation

    + checkCondition(Player): int
  }

  enum MonolithOrientation {
    LEFTDIAGONAL, RIGHTDIAGONAL
  }

  class CaveObjective implements Objective {
    - targetColor1: Color
    - targetColor2: Color
    - orientation: CaveOrientation

    + checkCondition(Player): int
  }

enum CaveOrientation {
    UPRIGHTL, UPRIGHTJ, INVERTEDL, INVERTEDJ
}

  class CoveredCornersObjective implements Objective {

    + checkCondition(Player): int
  }

  class BlankObjective implements Objective {

    ' Always returns 1
    + checkCondition(Player): int
  }

  ' Utile la differenzazione tra carte fisiche e giocabili(fronte/retro)
  class PhysicalCard {
    - front: PlayableCard
    - back: PlayableCard

    + getFront()
    + getBack()
  }

  ' Include anche carte Risorsa e Iniziali (non è più astratta)
  ' Niente setter perchè immutabili dopo l'inizializzazione
  class PlayableCard {
    - color: Color
    - score: int
    - fixedResources: List<Resource>
    - swCorner: Corner
    - nwCorner: Corner
    - neCorner: Corner
    - seCorner: Corner

    + getColor()
    + getScore()
    + getFixedResources()
    + getSwCorner()
    + getNwCorner()
    + getNeCorner()
    + getSeCorner()
  }

  ' La logica dietro i requisiti dei bonus è la stessa degli obiettivi
  class GoldCard extends PlayableCard{
    - constraint: Map<Resource,int>
    ' Il punteggio dato dalla carta sarà calcolato come
    ' score * bonus.checkCondition(player)
    - bonus: Objective

    + getConstraint()
    + getBonus()
  }

  enum Color {
    WHITE, GREEN, BLUE, RED, PURPLE
  }

}

@enduml