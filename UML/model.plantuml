@startuml model_entities

package model.entities {

  ' I tipi delle carte in queste prime classi sono stati cambiati
  ' in accordo con le modifiche effettuate
  class Game {
    - code: String
    - players: List<Player>
    - numPlayers: int
    - resourceDeck: Stack<PhysicalCard>
    - goldDeck: Stack<PhysicalCard>
    - revealedCards: PhysicalCard[4]
    - commonObjectives: ObjectiveCard[2]

    + start()
    + end()
    + join(Player)
    + setPlayerData(Player)
    + getPlayerData(Player)
    + setCommonGoals()
    + getCommonGoal1()
    + getCommonGoal2()
    + setPlayer(Player)
    + setDecks()
    + drawCard(DrawingPosition): RGCard
    - drawResourceDeck(): ResourceCard
    - drawGoldDeck(): GoldCard
  }

  enum DrawingPosition {
    RESOURCEDECK, RESOURCE1, RESOURCE2, GOLDDECK, GOLD1, GOLD2
  }

  ' Sincero non ho idea di come dovrebbe essere strutturata
  class Chat {
    ' ???
  }

  class Player {
    - nickname: String
    - status: PlayerStatus
    - playerData: PlayerData

    + setNickname()
    + getNickname(): String
    + setStatus()
    + getStatus(): PlayerStatus
  }

  enum PlayerStatus {
    CONNECTED, DISCONNECTED, QUITTED
  }

  class PlayerData {
    - cornersArea: Corner[82][82]
    - cardsArea: PlayableCard[82][82]
    - score: int
    - numResources: Map<Resources,int>
    - secretObjective: ObjectiveCard
    - hand: PhysicalCard[3]

    + getCornerArea()
    + getColorsArea()
    + getScore()
    + getNumResorces()
    + getSecretObjective()
    + getHand()
    - evaluateObjective(Objective): int
    + placeCard(PlayableCard, int, int): void
    + drawCard(DrawingPosition): PhysicalCard
  }

  ' Aggiunta la risorsa nulla
  enum Resource {
    PLANT, ANIMAL, FUNGI, INSECT, QUILL, SCROLL, INK
  }

  class Corner {
    - resource: Resource
    - status: CornerStatus

    + getResource()
    + getVisibility()
  }

  enum CornerStatus {
      HIDDEN, EMPTY, FULL
  }

  class ObjectiveCard {
    ' Il punteggio dato dalla carta sarà calcolato come
    ' pointsPerCompletion * objective.checkCondition(player)
    - pointsPerCompletion: int
    - objective: Objective

    + checkObjective()
  }

  '
  interface Objective {
    ' Indica il (massimo) numero di volte che un giocatore
    ' soddisfa l'obiettivo
    + checkCondition(Player): int
  }

  class IdenticalResourcesObjective implements Objective {
    - targetResource: Resource
    - count: int

    + checkCondition(Player): int
  }

  class DifferentResourcesObjective implements Objective {
    - targetResources: Set<Resource>

    + checkCondition(Player): int
  }

  class MonolithObjective implements Objective {
    - targetColor: Color
    - orientation: MonolithOrientation

    + checkCondition(Player): int
  }

  enum MonolithOrientation {
    LEFTDIAGONAL, RIGHTDIAGONAL
  }

  class CaveObjective implements Objective {
    - targetColor1: Color
    - targetColor2: Color
    - orientation: CaveOrientation

    + checkCondition(Player): int
  }

  enum CaveOrientation {
    UPRIGHTL, UPRIGHTJ, INVERTEDL, INVERTEDJ
  }

  ' Utile la differenzazione tra carte fisiche e giocabili(fronte/retro)
  class PhysicalCard {
    - front: PlayableCard
    - back: PlayableCard

    + getFront()
    + getBack()
  }

  ' Include anche carte Risorsa e Iniziali (non è più astratta)
  ' Niente setter perchè immutabili dopo l'inizializzazione
  class PlayableCard {
    - color: Color
    - points: int
    - fixedResources: List<Resource>
    - swCorner: Corner
    - nwCorner: Corner
    - neCorner: Corner
    - seCorner: Corner

    + getColor()
    + getPoints()
    + getFixedResources()
    + getSwCorner()
    + getNwCorner()
    + getNeCorner()
    + getSeCorner()
    + resourceCount(Resource): int
    + isPlaceable(Player, int, int)
  }

  enum Color {
    WHITE, GREEN, BLUE, RED, PURPLE
  }

  class GoldCard extends PlayableCard{
    - constraint: Map<Resource,int>
    ' Il punteggio dato dalla carta sarà calcolato come
    ' points * bonus.checkBonus(player, x, y)
    - bonus: Bonus

    + getConstraint()
    + getBonus()
    + isPlaceable(Player, int, int)
  }

  interface Bonus {
  ' Indica il numero di volte che il giocatore soddisferebbe
  ' il bonus piazzando la carta alle coordinate (x, y)
  + checkBonus(Player, int, int): int
  }

  class ResourcesBonus implements Bonus {
  - targetResource: Resource

  + checkBonus(Player, int, int): int
  }

  class CoveredCornersBonus implements Bonus {
  + checkBonus(Player, int, int): int
  }

}

@enduml